(ns arachne.core.config.impl.common
  (:require [clojure.walk :as w]
            [arachne.core.config :as cfg]))

(defn- replace-tempid
  [mapping a-tid tempid-fn]
  (if (mapping a-tid)
    mapping
    (assoc mapping a-tid
                   (if (.-id a-tid)
                     (tempid-fn (.-partition a-tid) (.-id a-tid))
                     (tempid-fn (.-partition a-tid))))))

;; Yes. I know this uses mutation. No time to write a `reduce` version of
;; clojure.walk
(defn- replace-tempids
  "Replace generic arachne.core.config.Tempid instances with
  implementation-specific tempids (generated by the provided function). The same
  Arachne ID instance will always resolve to the same implementation tempid
  instance. Return a tuple of the resultant txdata and a mapping of Arachne
  tempids to the corresponding implementation tempids."
  [data tempid-fn]
  (let [mapping (atom {})
        new-txdata (w/prewalk
                     (fn [val]
                       (if (instance? arachne.core.config.Tempid val)
                         ((swap! mapping replace-tempid val tempid-fn) val)
                         val))
                     data)]
    [new-txdata @mapping]))

(defn with
  "Add the given the given txdata, replacing Arachne tempids with
  implemenation-specific tempids. Adds an :arachne-tempids key to the map
  returned by `datomic.api/with`, containing a mapping of Arachne tempids to
  realized entity IDs."
  ([db txdata impl-with impl-tempid impl-resolve-tempid]
   (let [[txdata atid->dtid] (replace-tempids txdata impl-tempid)
         txresult (impl-with db txdata)]
     (assoc txresult
       :arachne-tempids
       (into {} (map (fn [[atid dtid]]
                       [atid (impl-resolve-tempid (:db-after txresult)
                               (:tempids txresult)
                               dtid)])
                  atid->dtid))))))
